/**
 * @file project_generator.h
 * @brief Generate CMake project structure for transpiled code
 */

#ifndef PROJECT_GENERATOR_H
#define PROJECT_GENERATOR_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

#ifdef _WIN32
#include <direct.h>
#define mkdir(path, mode) _mkdir(path)
#endif

/**
 * @brief Create directory if it doesn't exist
 */
static inline int create_directory(const char *path) {
    struct stat st = {0};
    if (stat(path, &st) == -1) {
        return mkdir(path, 0755);
    }
    return 0;
}

/**
 * @brief Generate CMakeLists.txt for the project
 */
static inline int generate_cmake(const char *project_dir, const char *project_name, 
                                int c_file_count, const char **c_files,
                                int h_file_count, const char **h_files) {
    char cmake_path[512];
    snprintf(cmake_path, sizeof(cmake_path), "%s/CMakeLists.txt", project_dir);
    
    FILE *f = fopen(cmake_path, "w");
    if (!f) {
        fprintf(stderr, "Error: Cannot create CMakeLists.txt\n");
        return -1;
    }
    
    fprintf(f, "cmake_minimum_required(VERSION 3.10)\n");
    fprintf(f, "project(%s C)\n\n", project_name);
    fprintf(f, "set(CMAKE_C_STANDARD 99)\n");
    fprintf(f, "set(CMAKE_C_STANDARD_REQUIRED ON)\n\n");
    
    fprintf(f, "# Include directories\n");
    fprintf(f, "include_directories(${CMAKE_SOURCE_DIR}/include)\n");
    fprintf(f, "# Add SDK include directory if it exists\n");
    fprintf(f, "if(EXISTS ${CMAKE_SOURCE_DIR}/sdk/include)\n");
    fprintf(f, "    include_directories(${CMAKE_SOURCE_DIR}/sdk/include)\n");
    fprintf(f, "endif()\n");
    fprintf(f, "if(EXISTS ${CMAKE_SOURCE_DIR}/src/sdk/include)\n");
    fprintf(f, "    include_directories(${CMAKE_SOURCE_DIR}/src/sdk/include)\n");
    fprintf(f, "endif()\n\n");
    
    fprintf(f, "# Compiler flags\n");
    fprintf(f, "if(MSVC)\n");
    fprintf(f, "    add_compile_options(/W4 /wd4996 /wd4244 /wd4267)\n");
    fprintf(f, "    # Disable warnings for deprecated functions and type conversions\n");
    fprintf(f, "else()\n");
    fprintf(f, "    add_compile_options(-Wall -Wextra -Wpedantic)\n");
    fprintf(f, "endif()\n\n");
    
    fprintf(f, "# Automatically find all source files recursively\n");
    fprintf(f, "# This includes transpiled files and SDK files if they're in src/\n");
    fprintf(f, "file(GLOB_RECURSE SOURCES \n");
    fprintf(f, "    \"src/*.c\"\n");
    fprintf(f, ")\n\n");
    
    fprintf(f, "# Also find SDK files if they're in a separate sdk/ directory\n");
    fprintf(f, "if(EXISTS ${CMAKE_SOURCE_DIR}/sdk)\n");
    fprintf(f, "    file(GLOB_RECURSE SDK_SOURCES \"sdk/src/*.c\")\n");
    fprintf(f, "    list(APPEND SOURCES ${SDK_SOURCES})\n");
    fprintf(f, "endif()\n\n");
    
    fprintf(f, "# Automatically find all header files (for IDE project view)\n");
    fprintf(f, "# This includes transpiled headers and SDK headers if they're in include/\n");
    fprintf(f, "file(GLOB_RECURSE HEADERS \n");
    fprintf(f, "    \"include/*.h\"\n");
    fprintf(f, ")\n\n");
    
    fprintf(f, "# Also find SDK headers if they're in a separate sdk/ directory\n");
    fprintf(f, "if(EXISTS ${CMAKE_SOURCE_DIR}/sdk)\n");
    fprintf(f, "    file(GLOB_RECURSE SDK_HEADERS \"sdk/include/*.h\")\n");
    fprintf(f, "    list(APPEND HEADERS ${SDK_HEADERS})\n");
    fprintf(f, "endif()\n\n");
    
    fprintf(f, "# Print number of files found (helpful for debugging)\n");
    fprintf(f, "list(LENGTH SOURCES SOURCE_COUNT)\n");
    fprintf(f, "list(LENGTH HEADERS HEADER_COUNT)\n");
    fprintf(f, "message(STATUS \"Found ${SOURCE_COUNT} source files and ${HEADER_COUNT} header files\")\n\n");
    
    fprintf(f, "# Create executable\n");
    fprintf(f, "add_executable(${PROJECT_NAME} ${SOURCES} ${HEADERS})\n\n");
    
    fprintf(f, "# Link libraries (if needed)\n");
    fprintf(f, "if(UNIX)\n");
    fprintf(f, "    target_link_libraries(${PROJECT_NAME} m)\n");
    fprintf(f, "endif()\n");
    
    fclose(f);
    return 0;
}

/**
 * @brief Generate main.c entry point
 */
static inline int generate_main_c(const char *project_dir) {
    char main_path[512];
    snprintf(main_path, sizeof(main_path), "%s/src/main.c", project_dir);
    
    FILE *f = fopen(main_path, "w");
    if (!f) {
        fprintf(stderr, "Error: Cannot create main.c\n");
        return -1;
    }
    
    fprintf(f, "/**\n");
    fprintf(f, " * @file main.c\n");
    fprintf(f, " * @brief Entry point wrapper for transpiled GameCube code\n");
    fprintf(f, " * Generated by Porpoise Tool\n");
    fprintf(f, " * \n");
    fprintf(f, " * If the game has a real main() at 0x80004000, this wrapper initializes\n");
    fprintf(f, " * the runtime environment and calls it. Otherwise, you can add test code here.\n");
    fprintf(f, " */\n\n");
    
    fprintf(f, "#include <stdio.h>\n");
    fprintf(f, "#include <stdint.h>\n");
    fprintf(f, "#include <stdlib.h>\n");
    fprintf(f, "#include \"powerpc_state.h\"\n");
    fprintf(f, "#include \"all_functions.h\"\n");
    fprintf(f, "#include \"function_address_map.h\"\n\n");
    
    fprintf(f, "// Forward declare GameCube startup function\n");
    fprintf(f, "// __start() performs OS initialization and then calls the game's main() function\n");
    fprintf(f, "extern void __start(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, double, double);\n\n");
    
    fprintf(f, "/**\n");
    fprintf(f, " * @brief Program entry point\n");
    fprintf(f, " * \n");
    fprintf(f, " * Initializes the PowerPC emulation environment and either:\n");
    fprintf(f, " * 1. Calls game_main() if it exists (GameCube/Wii games start at 0x80004000), OR\n");
    fprintf(f, " * 2. Provides a test harness for calling individual functions\n");
    fprintf(f, " */\n");
    fprintf(f, "int main(int argc, char *argv[]) {\n");
    fprintf(f, "    (void)argc;  // Suppress unused parameter warning\n");
    fprintf(f, "    (void)argv;\n\n");
    fprintf(f, "    printf(\"Transpiled GameCube Code - Porpoise Tool\\n\");\n");
    fprintf(f, "    printf(\"=============================================\\n\\n\");\n\n");
    
    fprintf(f, "    // Initialize PowerPC runtime environment\n");
    fprintf(f, "    if (runtime_init() != 0) {\n");
    fprintf(f, "        fprintf(stderr, \"ERROR: Failed to initialize runtime\\n\");\n");
    fprintf(f, "        return 1;\n");
    fprintf(f, "    }\n\n");
    
    fprintf(f, "    // Initialize function registry for indirect calls\n");
    fprintf(f, "    extern void init_function_registry(void);\n");
    fprintf(f, "    init_function_registry();\n\n");
    
    fprintf(f, "    printf(\"Runtime initialized successfully\\n\");\n");
    fprintf(f, "    printf(\"  - Emulated memory: %%d MB\\n\", MEM_SIZE / (1024 * 1024));\n");
    fprintf(f, "    printf(\"  - PowerPC registers: Ready\\n\");\n");
    fprintf(f, "    printf(\"  - Function registry: Loaded\\n\\n\");\n\n");
    
    fprintf(f, "    // Call the GameCube startup function\n");
    fprintf(f, "    // __start() performs OS initialization (OSInit, hardware setup, etc.)\n");
    fprintf(f, "    // and then calls the game's main() function (renamed to main_impl)\n");
    fprintf(f, "    printf(\"Calling game's __start()...\\n\\n\");\n");
    fprintf(f, "    __start(0, 0, 0, 0, 0, 0, 0, 0, 0.0, 0.0);  // Call GameCube startup\n\n");
    
    fprintf(f, "    // If you want to call individual functions instead of __start(), add test code here:\n");
    fprintf(f, "    // printf(\"Add function calls here for testing.\\n\");\n");
    fprintf(f, "    // r3 = 0x12345678;  // Set up parameter\n");
    fprintf(f, "    // fn_80010BBC();    // Call transpiled function\n");
    fprintf(f, "    // printf(\"Result in r3: 0x%%08X\\n\", r3);\n\n");
    
    fprintf(f, "    printf(\"\\nExecution complete\\n\");\n\n");
    
    fprintf(f, "    // Cleanup\n");
    fprintf(f, "    runtime_cleanup();\n");
    fprintf(f, "    return 0;\n");
    fprintf(f, "}\n");
    
    fclose(f);
    return 0;
}

/**
 * @brief Generate runtime.h header
 */
static inline int generate_runtime_h(const char *project_dir) {
    char runtime_path[512];
    snprintf(runtime_path, sizeof(runtime_path), "%s/include/powerpc_state.h", project_dir);
    
    FILE *f = fopen(runtime_path, "w");
    if (!f) {
        fprintf(stderr, "Error: Cannot create powerpc_state.h\n");
        return -1;
    }
    
    fprintf(f, "/**\n");
    fprintf(f, " * @file powerpc_state.h\n");
    fprintf(f, " * @brief PowerPC register state for transpiled GameCube code\n");
    fprintf(f, " */\n\n");
    
    fprintf(f, "#ifndef POWERPC_STATE_H\n");
    fprintf(f, "#define POWERPC_STATE_H\n\n");
    
    fprintf(f, "#include <stdint.h>\n");
    fprintf(f, "#include <stdbool.h>\n\n");
    
    fprintf(f, "// Compiler compatibility macros\n");
    fprintf(f, "#ifdef _MSC_VER\n");
    fprintf(f, "    #define ASM_VOLATILE(x) /* MSVC doesn't support inline asm */\n");
    fprintf(f, "#else\n");
    fprintf(f, "    #define ASM_VOLATILE(x) __asm__ volatile(x)\n");
    fprintf(f, "#endif\n\n");
    
    fprintf(f, "// Suppress warnings for generated code\n");
    fprintf(f, "#ifdef _MSC_VER\n");
    fprintf(f, "    #pragma warning(disable: 4102)  // unreferenced label\n");
    fprintf(f, "    #pragma warning(disable: 4244)  // conversion warnings\n");
    fprintf(f, "    #pragma warning(disable: 4245)  // signed/unsigned mismatch\n");
    fprintf(f, "#endif\n\n");
    
    fprintf(f, "// PowerPC register state\n");
    fprintf(f, "// Using uintptr_t to hold both GameCube 32-bit values and 64-bit host pointers\n");
    fprintf(f, "extern uintptr_t r0, r1, r2, r3, r4, r5, r6, r7;\n");
    fprintf(f, "extern uintptr_t r8, r9, r10, r11, r12, r13, r14, r15;\n");
    fprintf(f, "extern uintptr_t r16, r17, r18, r19, r20, r21, r22, r23;\n");
    fprintf(f, "extern uintptr_t r24, r25, r26, r27, r28, r29, r30, r31;\n\n");
    
    fprintf(f, "extern double f0, f1, f2, f3, f4, f5, f6, f7;\n");
    fprintf(f, "extern double f8, f9, f10, f11, f12, f13, f14, f15;\n");
    fprintf(f, "extern double f16, f17, f18, f19, f20, f21, f22, f23;\n");
    fprintf(f, "extern double f24, f25, f26, f27, f28, f29, f30, f31;\n\n");
    
    fprintf(f, "extern uint32_t cr0, cr1, cr2, cr3, cr4, cr5, cr6, cr7;\n");
    fprintf(f, "extern uint32_t cr, xer, lr, ctr, pc, fpscr;\n");
    fprintf(f, "extern uint32_t sr[16];  // Segment registers\n");
    fprintf(f, "extern uint32_t tbl, tbu;\n\n");
    
    fprintf(f, "// Common SPRs\n");
    fprintf(f, "extern uint32_t msr, srr0, srr1;\n");
    fprintf(f, "extern uint32_t sprg0, sprg1, sprg2, sprg3;\n");
    fprintf(f, "extern uint32_t hid0, hid1, hid2, hid4;\n");
    fprintf(f, "extern uint32_t gqr0, gqr1, gqr2, gqr3, gqr4, gqr5, gqr6, gqr7;\n");
    fprintf(f, "extern uint32_t pvr;  // Processor Version Register\n");
    fprintf(f, "extern uint32_t *spr;  // Generic SPR array\n\n");
    
    fprintf(f, "extern uint8_t *mem;  // Emulated memory\n");
    fprintf(f, "#define MEM_SIZE (64 * 1024 * 1024)  // 64MB\n");
    fprintf(f, "#define MEM_BASE 0x80000000  // GameCube RAM base address\n\n");
    
    fprintf(f, "// Safe address translation macro - translates GameCube addresses to mem buffer offsets\n");
    fprintf(f, "// Must be a macro (not inline function) to avoid linker issues in C99 mode\n");
    fprintf(f, "#define translate_address(addr) \\\n");
    fprintf(f, "    (((addr) >= MEM_BASE && (addr) < (MEM_BASE + MEM_SIZE)) \\\n");
    fprintf(f, "     ? (mem + ((addr) - MEM_BASE)) \\\n");
    fprintf(f, "     : mem)  /* Return mem base for invalid addresses */\n\n");
    
    fprintf(f, "/**\n");
    fprintf(f, " * @brief Initialize the runtime environment\n");
    fprintf(f, " * @return 0 on success, -1 on failure\n");
    fprintf(f, " */\n");
    fprintf(f, "int runtime_init(void);\n\n");
    
    fprintf(f, "/**\n");
    fprintf(f, " * @brief Cleanup the runtime environment\n");
    fprintf(f, " */\n");
    fprintf(f, "void runtime_cleanup(void);\n\n");
    
    fprintf(f, "#endif // POWERPC_STATE_H\n");
    
    fclose(f);
    return 0;
}

/**
 * @brief Generate powerpc_state.c implementation
 */
static inline int generate_runtime_c(const char *project_dir) {
    char runtime_path[512];
    snprintf(runtime_path, sizeof(runtime_path), "%s/src/powerpc_state.c", project_dir);
    
    FILE *f = fopen(runtime_path, "w");
    if (!f) {
        fprintf(stderr, "Error: Cannot create powerpc_state.c\n");
        return -1;
    }
    
    fprintf(f, "/**\n");
    fprintf(f, " * @file powerpc_state.c\n");
    fprintf(f, " * @brief PowerPC register state implementation\n");
    fprintf(f, " */\n\n");
    
    fprintf(f, "#include \"powerpc_state.h\"\n");
    fprintf(f, "#include <stdlib.h>\n");
    fprintf(f, "#include <string.h>\n\n");
    
    fprintf(f, "// PowerPC register state\n");
    fprintf(f, "// Using uintptr_t to hold both GameCube 32-bit values and 64-bit host pointers\n");
    fprintf(f, "uintptr_t r0, r1, r2, r3, r4, r5, r6, r7;\n");
    fprintf(f, "uintptr_t r8, r9, r10, r11, r12, r13, r14, r15;\n");
    fprintf(f, "uintptr_t r16, r17, r18, r19, r20, r21, r22, r23;\n");
    fprintf(f, "uintptr_t r24, r25, r26, r27, r28, r29, r30, r31;\n\n");
    
    fprintf(f, "double f0, f1, f2, f3, f4, f5, f6, f7;\n");
    fprintf(f, "double f8, f9, f10, f11, f12, f13, f14, f15;\n");
    fprintf(f, "double f16, f17, f18, f19, f20, f21, f22, f23;\n");
    fprintf(f, "double f24, f25, f26, f27, f28, f29, f30, f31;\n\n");
    
    fprintf(f, "uint32_t cr0, cr1, cr2, cr3, cr4, cr5, cr6, cr7;\n");
    fprintf(f, "uint32_t cr, xer, lr, ctr, pc, fpscr;\n");
    fprintf(f, "uint32_t sr[16];\n");
    fprintf(f, "uint32_t tbl, tbu;\n\n");
    
    fprintf(f, "// Common SPRs\n");
    fprintf(f, "uint32_t msr, srr0, srr1;\n");
    fprintf(f, "uint32_t sprg0, sprg1, sprg2, sprg3;\n");
    fprintf(f, "uint32_t hid0, hid1, hid2, hid4;\n");
    fprintf(f, "uint32_t gqr0, gqr1, gqr2, gqr3, gqr4, gqr5, gqr6, gqr7;\n");
    fprintf(f, "uint32_t pvr;  // Processor Version Register\n");
    fprintf(f, "uint32_t spr_array[1024];  // Generic SPR storage\n");
    fprintf(f, "uint32_t *spr = spr_array;\n\n");
    
    fprintf(f, "uint8_t *mem = NULL;\n\n");
    
    fprintf(f, "int runtime_init(void) {\n");
    fprintf(f, "    // Allocate emulated memory\n");
    fprintf(f, "    mem = (uint8_t*)calloc(MEM_SIZE, 1);\n");
    fprintf(f, "    if (!mem) {\n");
    fprintf(f, "        return -1;\n");
    fprintf(f, "    }\n\n");
    
    fprintf(f, "    // Initialize registers\n");
    fprintf(f, "    memset(sr, 0, sizeof(sr));\n");
    fprintf(f, "    r1 = 0x81700000;  // Stack pointer (stack grows downward)\n");
    fprintf(f, "    // r2 and r13 are Small Data Area bases - from __start.s\n");
    fprintf(f, "    r2 = 0x804DF9E0;  // SDA2 base (_SDA2_BASE_)\n");
    fprintf(f, "    r13 = 0x804DB6A0; // SDA base (_SDA_BASE_)\n\n");
    
    fprintf(f, "    return 0;\n");
    fprintf(f, "}\n\n");
    
    fprintf(f, "void runtime_cleanup(void) {\n");
    fprintf(f, "    if (mem) {\n");
    fprintf(f, "        free(mem);\n");
    fprintf(f, "        mem = NULL;\n");
    fprintf(f, "    }\n");
    fprintf(f, "}\n");
    
    fclose(f);
    return 0;
}

/**
 * @brief Generate compiler_runtime.c with compiler helper functions
 */
static inline int generate_compiler_runtime_c(const char *project_dir) {
    char runtime_path[512];
    snprintf(runtime_path, sizeof(runtime_path), "%s/src/compiler_runtime.c", project_dir);
    
    FILE *f = fopen(runtime_path, "w");
    if (!f) {
        fprintf(stderr, "Error: Cannot create compiler_runtime.c\n");
        return -1;
    }
    
    fprintf(f, "/**\n");
    fprintf(f, " * @file compiler_runtime.c\n");
    fprintf(f, " * @brief PowerPC EABI compiler runtime helper functions\n");
    fprintf(f, " * \n");
    fprintf(f, " * These functions are typically provided by the compiler's runtime library.\n");
    fprintf(f, " * For the transpiler, we provide stub implementations.\n");
    fprintf(f, " */\n\n");
    
    fprintf(f, "#include <stdint.h>\n");
    fprintf(f, "#include \"powerpc_state.h\"\n\n");
    
    fprintf(f, "// ============================================================================\n");
    fprintf(f, "// Register Save/Restore Helpers (PowerPC EABI)\n");
    fprintf(f, "// ============================================================================\n");
    fprintf(f, "// Note: In our emulated environment, these are no-ops since registers are globals\n\n");
    
    // Generate _savegpr and _restgpr functions
    for (int i = 14; i <= 31; i++) {
        fprintf(f, "void _savegpr_%d(void) { /* Registers are globals, no save needed */ }\n", i);
    }
    fprintf(f, "\n");
    for (int i = 14; i <= 31; i++) {
        fprintf(f, "void _restgpr_%d(void) { /* Registers are globals, no restore needed */ }\n", i);
    }
    fprintf(f, "\n");
    
    // Generate _savefpr and _restfpr functions
    for (int i = 14; i <= 31; i++) {
        fprintf(f, "void _savefpr_%d(void) { /* Registers are globals, no save needed */ }\n", i);
    }
    fprintf(f, "\n");
    for (int i = 14; i <= 31; i++) {
        fprintf(f, "void _restfpr_%d(void) { /* Registers are globals, no restore needed */ }\n", i);
    }
    fprintf(f, "\n");
    
    fprintf(f, "// ============================================================================\n");
    fprintf(f, "// Compiler Intrinsics\n");
    fprintf(f, "// ============================================================================\n");
    fprintf(f, "// Note: __cvt_fp2unsigned, __div2u, __mod2u, __save_gpr, __restore_gpr,\n");
    fprintf(f, "//       __save_fpr, __restore_fpr are provided by runtime.c\n\n");
    
    fprintf(f, "/**\n");
    fprintf(f, " * @brief Count leading zeros\n");
    fprintf(f, " */\n");
    fprintf(f, "int __builtin_clz(unsigned int x) {\n");
    fprintf(f, "    if (x == 0) return 32;\n");
    fprintf(f, "    int count = 0;\n");
    fprintf(f, "    while ((x & 0x80000000) == 0) {\n");
    fprintf(f, "        count++;\n");
    fprintf(f, "        x <<= 1;\n");
    fprintf(f, "    }\n");
    fprintf(f, "    return count;\n");
    fprintf(f, "}\n");
    
    fclose(f);
    return 0;
}

/**
 * @brief Generate README.md
 */
static inline int generate_readme(const char *project_dir, const char *project_name) {
    char readme_path[512];
    snprintf(readme_path, sizeof(readme_path), "%s/README.md", project_dir);
    
    FILE *f = fopen(readme_path, "w");
    if (!f) {
        fprintf(stderr, "Error: Cannot create README.md\n");
        return -1;
    }
    
    fprintf(f, "# %s\n\n", project_name);
    fprintf(f, "Transpiled GameCube/Wii code generated by Porpoise Tool.\n\n");
    
    fprintf(f, "## Building\n\n");
    fprintf(f, "```bash\n");
    fprintf(f, "mkdir build\n");
    fprintf(f, "cd build\n");
    fprintf(f, "cmake ..\n");
    fprintf(f, "cmake --build .\n");
    fprintf(f, "```\n\n");
    
    fprintf(f, "## Running\n\n");
    fprintf(f, "```bash\n");
    fprintf(f, "./build/%s\n", project_name);
    fprintf(f, "```\n\n");
    
    fprintf(f, "## Project Structure\n\n");
    fprintf(f, "```\n");
    fprintf(f, "%s/\n", project_name);
    fprintf(f, "├── CMakeLists.txt    # CMake build configuration\n");
    fprintf(f, "├── README.md         # This file\n");
    fprintf(f, "├── include/          # Header files\n");
    fprintf(f, "│   ├── runtime.h     # Runtime environment\n");
    fprintf(f, "│   └── *.h           # Transpiled headers\n");
    fprintf(f, "└── src/              # Source files\n");
    fprintf(f, "    ├── main.c        # Entry point\n");
    fprintf(f, "    ├── runtime.c     # Runtime implementation\n");
    fprintf(f, "    └── *.c           # Transpiled source files\n");
    fprintf(f, "```\n\n");
    
    fprintf(f, "## Notes\n\n");
    fprintf(f, "- All PowerPC registers are emulated as global variables\n");
    fprintf(f, "- Memory is emulated as a 64MB buffer\n");
    fprintf(f, "- Branch targets and labels are preserved\n");
    fprintf(f, "- Generated by Porpoise Tool - PowerPC to C Transpiler\n");
    
    fclose(f);
    return 0;
}

/**
 * @brief Generate master header that includes all transpiled headers
 */
static inline int generate_all_functions_h(const char *project_dir, int file_count, const char **h_files) {
    char master_path[512];
    snprintf(master_path, sizeof(master_path), "%s/include/all_functions.h", project_dir);
    
    FILE *f = fopen(master_path, "w");
    if (!f) {
        fprintf(stderr, "Error: Cannot create all_functions.h\n");
        return -1;
    }
    
    fprintf(f, "/**\n");
    fprintf(f, " * @file all_functions.h\n");
    fprintf(f, " * @brief Master header including all transpiled function declarations\n");
    fprintf(f, " * Include this in .c files to enable cross-file function calls\n");
    fprintf(f, " */\n\n");
    
    fprintf(f, "#ifndef ALL_FUNCTIONS_H\n");
    fprintf(f, "#define ALL_FUNCTIONS_H\n\n");
    
    fprintf(f, "// Include all transpiled headers\n");
    for (int i = 0; i < file_count; i++) {
        fprintf(f, "#include \"%s\"\n", h_files[i]);
    }
    
    fprintf(f, "\n#endif // ALL_FUNCTIONS_H\n");
    
    fclose(f);
    return 0;
}

/**
 * @brief Generate stub macros.h file
 */
static inline int generate_macros_h(const char *project_dir) {
    char macros_path[512];
    snprintf(macros_path, sizeof(macros_path), "%s/include/macros.h", project_dir);
    
    FILE *f = fopen(macros_path, "w");
    if (!f) {
        fprintf(stderr, "Error: Cannot create macros.h\n");
        return -1;
    }
    
    fprintf(f, "/**\n");
    fprintf(f, " * @file macros.h\n");
    fprintf(f, " * @brief Stub file for assembly macro includes\n");
    fprintf(f, " * Add your custom macros here if needed\n");
    fprintf(f, " */\n\n");
    
    fprintf(f, "#ifndef MACROS_H\n");
    fprintf(f, "#define MACROS_H\n\n");
    
    fprintf(f, "#include <stdint.h>\n");
    fprintf(f, "#include <stdbool.h>\n\n");
    
    fprintf(f, "// Add any custom macros or definitions here\n");
    fprintf(f, "// This file is a stub for .include \"macros.inc\" conversions\n\n");
    
    fprintf(f, "#endif // MACROS_H\n");
    
    fclose(f);
    return 0;
}

/**
 * @brief Generate .gitignore
 */
static inline int generate_gitignore(const char *project_dir) {
    char gitignore_path[512];
    snprintf(gitignore_path, sizeof(gitignore_path), "%s/.gitignore", project_dir);
    
    FILE *f = fopen(gitignore_path, "w");
    if (!f) {
        fprintf(stderr, "Error: Cannot create .gitignore\n");
        return -1;
    }
    
    fprintf(f, "# Build directories\n");
    fprintf(f, "build/\n");
    fprintf(f, "cmake-build-*/\n\n");
    
    fprintf(f, "# CMake\n");
    fprintf(f, "CMakeCache.txt\n");
    fprintf(f, "CMakeFiles/\n");
    fprintf(f, "cmake_install.cmake\n");
    fprintf(f, "Makefile\n\n");
    
    fprintf(f, "# Executables\n");
    fprintf(f, "*.exe\n");
    fprintf(f, "*.out\n\n");
    
    fprintf(f, "# IDE\n");
    fprintf(f, ".vscode/\n");
    fprintf(f, ".idea/\n");
    fprintf(f, "*.swp\n");
    fprintf(f, "*~\n");
    
    fclose(f);
    return 0;
}

/**
 * @brief Generate function_registry.c with all function mappings
 * This function must be called from porpoise_tool.c where function_registry is accessible
 */
static inline int generate_function_registry_impl(const char *project_dir,
                                                  void *registry, int count) {
    // This is a placeholder - the actual implementation needs access to function_registry
    // which is defined in porpoise_tool.c
    (void)project_dir;
    (void)registry;
    (void)count;
    return 0;
}

#endif // PROJECT_GENERATOR_H

